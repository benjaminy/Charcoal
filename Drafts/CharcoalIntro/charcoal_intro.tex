\documentclass[11pt,preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{2014} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

\titlebanner{Preprint.  Please do not redistribute}        % These are ignored unless
\preprintfooter{Preprint.  Please do not redistribute}   % 'preprint' option specified.

\title{Activities: A Framework for Writing Reliable, Modular and Maintainable Interactive Software}
\subtitle{Threads and Events Considered Harmful}

\authorinfo{Benjamin Ylvisaker}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

Writing safe, efficient and maintainable multitasking software is hard.
The most popular abstractions for building such software (event loops, threads, coroutines) all have significant weaknesses.
This paper describes a new abstraction called pseudo-preemptive threads (or \emph{activities}) that promises to make writing multitasking software easier.
We have implemented a dialect of C that has activities, written a collection of microbenchmarks and translated a couple of nontrivial multithreaded C programs to use activities instead of threads.
This paper presents both abstract arguments in favor of acitivities and the results of the prototype experiments.

\subsection{Established Multitasking Abstractions}

The three most widely used abstractions for multitasking software each suffers from serious software engineering difficulties.

\subsubsection{Event Loops}

Event loops are the most popular multitasking abstraction for relatively simple applications.
Most GUI frameworks use event loops to dispatch events like mouse clicks and keyboard presses to event handler procedures.
Until recently this was the only available multitasking abstraction for JavaScript code running in browsers.

The primary strength of event loops is that relative to other multitasking abstractions it is easy for application programmers to avoid concurrency bugs.
Only one event handler can be running at a time and the active handler must complete before another handler can run.

The primary weakness of event loops is that long-running tasks must be manually broken up into smaller pieces by the application programmer.
This can lead to a style of programming referred to as ``callback hell''.
Though the callback-heavy coding style has its defenders, there are also good arguments against it; a starting point for the large volumes of critique is \cite{Behren2003a}.

Another piece of evidence for the unsatisfactoryness of event loops is that several modern programming ecosystems have moved from event loops to coroutines; example include async/await in C#/.NET and generator functions (\texttt{function*}) in recent versions of JavaScript.

\subsubsection{Threads}

Event loops are at the safest and least flexible end of the multitasking abstraction spectrum and threads occupy the opposite corner.
(In this paper we use \emph{thread} to mean preemptive thread.)

The primary strength of threads is that if one is blocked waiting for an event to happen, other threads can make progress.
This makes it possible to write multitasking software in a natural single-task style (i.e. threads completely avoid callback hell).

The primary weakness of threads is that they make it very hard to avoid concurrency bugs like data races, deadlocks, atomicity violations and livelocks.
In the last decade a significant amount of research effort has been devoted to making threads easier to use, because of their application to programming multicore processors.
While some of this research is quite impressive, most mainstream application programmers still view threads as too dangerous for multitasking programming (correctly in the current authors' opinion).

Among the multitasking abstractions discussed in this paper, threads are unique in that they permit the parallel execution of tasks.
From the perspective of multitasking, parallelism is largely irrelevant; multitasking abstractions like event loops and coroutines can be used in tandem with parallelism abstractions like threads and processes.

\subsubsection{Coroutines}

Coroutines have an interesting history.
According to Knuth, the term was coined in 1958, but coroutines remained on the margins of mainstream software practice until recently.
For example, the async/await framework was added to C# in version 5, which was released in 2012.

Using the coroutine abstraction requires application programmers to partition procedures into normal procedures (functions, methods, subroutines, whatever) and coroutines.
In most implementations the procedure calling syntax is overloaded; calling a coroutine is actually a task spawn.
Within the static scope of a coroutine, a yield (or await) primitive can be used to context switch to a different task.
Invoking yield in a normal procedure is not permitted.

Relative to event loops, coroutines provide greater flexibility, because multiple tasks can be in progress at the same time.
Coroutines are much more resistant to concurrency bugs than threads, because only one coroutine can be active at a time, and the application explicitly states when switching between tasks is permitted.

The primary weakness of coroutines is a subtle tension with conventional procedural abstraction.
It is not possible to yield from a procedure called by a coroutine.
This can be quite inconvenient on its own, and it makes refactoring patterns like procedure extraction much trickier to apply.
Another consequence of this issue is that coroutines tend to be viral; if a programmer decides to convert a procedure to a coroutine (for example because it needs to wait for an event), it tends to be the case that any callers of that procedure need to be converted to coroutines as well.
Similarly, higher-order function patterns get more complicated as well.
There are now two distinct kinds of procedure-like-things.

These software engineering awkwardnesses have not prevented the adoption of coroutines, but they are annoying.
Activities solve these problems!

\subsubsection{Cooperative Threads}

Cooperative threads can be seen as a compromise between coroutines and (preemptive) threads.
Like coroutines, cooperative threads must invoke a yield primitive to switch from one task to another.
Like threads, cooperative thread abstractions do not have a separate kind of procedure (i.e. coroutine/async) and yield can be invoked anywhere (i.e. not restricted to coroutine bodies).

Cooperative threads have a tension with procedural abstraction that is complementary to the problem coroutines have.
The atomicity properties of a particular procedure depend on whether or not any of the procedures it calls will invoke yield.
This can be annoying when initially writing code, and it is especially problematic during maintenance.
If yield is added to a procedure that did not previously have it, there is the possibility that any caller of that procedure will have its atomicity properties violated.
This is extra nasty when indirect calls are considered, because it is not possible in general to identify all possible call sites to a particular procedure.

\subsubsection{Others}

There are other approaches to multitasking that we briefly mention here only to argue that they are not directly relevant to the main point of this paper.

Isolated processes can be used for multitasking, but are far too heavy for the kinds of applications we are focused on (like GUI events and asynchronous network downloads).

Functional reactive programming (FRP) is an entirely different approach to multitasking.
It is interesting, but still at an early enough stage of development that it is not clear whether it can be integrated with mainstream programming practice.

\section{Pseudo-Preemptive Threads}

In this section we describe the new abstraction we call \emph{pseudo-preemptive threads}, or \emph{activities}.
Activities can be seen as a compromise between cooperative threads and preemptive threads.
Like cooperative threads, only one activity can be running at a time and a yield primitive must be invoked to allow task switching.
However, in order for a language to support threads it must implicitly and frequently invoke yield.
(What we mean by frequently is explained in detail below.)
This implicit frequent yielding makes the behavior of activities from an application programmer's perspective more like preemptive threads.

\section{Implementation}

Heap-allocation of call frames can be much faster
(e.g. \cite{Shao2000}).  That was not our focus here.  Important
observation: we do not \emph{need} super-fast call and return in the
might-yield context, because calls that really matter in that way should
happen in an unyielding context.

There is another hybrid scheme called ``split'' or ``segmented'' stacks
for (de)allocating call frames efficiently for multithreaded software.
The idea is that stack space is allocated in small chunks (or segments).
The common case call/return execution looks like traditional stack
allocation.  When a thread reaches the end of its segment it allocates a
new one and links them together.  This idea has a lot of appeal (the
implementers of Rust and Go both used it), but it has some really
unpleasant uncommon case behavior (the implementers of Rust and Go both
abandonded it in later versions).

\subsection{Fast and Slow}

One of the important features of the implementation is that there are
two versions of each procedure: an unyielding version and a might-yield
version.

Wait, don't we know whether a procedure is yielding or not?  Well, yes,
but \ldots For procedures marked unyielding, we know there is no need to
compile a might-yield version.  For other procedures we generally need
to compile both versions, because the procedure might be called in
either of the contexts.  The compiler might be able to do some analysis
to prove that one or the other version is never called and can therefore
be excised as dead code.

This is kinda related to ideas from the Cilk-5 implementation
\cite{Frigo1998}.

\section{Foreign Code}

Foreign code (including legacy code) will never yield.  This could lead
to starvation pretty easily.  Here are three strategies:

\begin{itemize}
\item Do nothing.  Just run the foreign code.  This is a perfectly
  reasonable strategy as long as the foreign code does not run for a
  long time.
\item Run the foreign code in its own thread.  If it has not returned by
  the end of some time slice, pause it to allow other activities to run.
  This runs the risk of creating atomicity violations galore.  It also
  reintroduces the possibility of data races.  However, it might be a
  reasonable strategy in situations where there is very little sharing
  between the foreign code and the rest of the application.
\item Run the foreign code in its own thread, but only interrupt it at
  special ``safe-ish'' points, like system calls.  This is a compromise
  between the previous two strategies in the sense that it opens the
  door to both starvation and atomicity violations, but provides some
  (imperfect) protection against both.
\end{itemize}

We have not thought at all about what the best default is or what
syntactic sugar would be nice.

Another important implementation issue to consider is foreign code that
calls back in to activity-aware code.  There will definitely be some
fancy footwork necessary there, no matter which strategy is used.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
