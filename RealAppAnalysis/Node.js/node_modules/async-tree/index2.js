'use strict';

const async_hooks = require("async_hooks");

var tree = {};
var fs = require('fs');

var parentID = 0;
var callbackID = 0;
var asyncCallbacks = [];
var timeline = [];
var len = 0;

const eid = async_hooks.executionAsyncId();

/**
 * AsyncListener object
 */
var AsyncListener = {};

var AsyncHook = 
{
	init(asyncId, type, triggerAsyncId)
	{
		const eid = async_hooks.executionAsyncId();
		fs.writeSync(1, 
			`${type}(${asyncId}): trigger: ${triggerAsyncId} execution: ${eid}\n`);

    	// This always gets called in between before/after
    	callbackID += 1;

    	//Signifies that a callback has been queued, but there is
    	//no guarantee that this callback will run
    	asyncCallbacks.push( {"initiator": parentID, "ID": callbackID} );
    	return callbackID;
	},

	before(asyncId) 
	{
    	parentID = callbackID;

    	//Because the order of creating callbacks is not the same as
    	//the order in which these callbacks are executed, a timeline
    	//can be kept
    	timeline.push({"ID": callbackID, "start": process.hrtime()[1]});
	},

	after(asyncId) 
	{
		//Duration can be computed
		timeline[timeline.length - 1]["end"] = process.hrtime()[1];
	}
}

async_hooks.createHook(AsyncHook).enable();


function printasyncCallbacks(){
  console.log(asyncCallbacks);
}

function get_tree( asyncCallbacks ) {
  var tree = { 0:{} }
  get_tree_helper(asyncCallbacks, tree[0],  0 );
  return tree;
}

function get_tree_helper(asyncCallbacks, tree, prevParent ) {
    for (var j = 0; j < asyncCallbacks.length; j++){
      var callback = asyncCallbacks[j];
      if (prevParent === call.initiator){
        tree[callback.ID] = {}
        get_tree_helper(asyncCallbacks, tree[callback.ID], callback.ID);
      }
    }
}


function tree_to_dot_code(){
  var str = "digraph {\n";

  for (var i = 0; i < len; i++){
  	var callback = asyncCallbacks[i];
  	console.log(callback);
    var parent = callback.initiator;
    var child = callback.ID;
    str += parent + " -> " + child +"\n";
  }

  str += "}";

  return str;
}

function create_dot_file(){
  //The length of asyncCallbacks GROWS even after process exits
  //Due to callbacks being queued during the exiting process..
  len = asyncCallbacks.length;
  var code = tree_to_dot_code() 
  fs.writeFileSync('dotgraph', code);
  console.log(code);
}

function finalize(){
	console.log("Initiator-Callback")
	create_dot_file();
	console.log("Timeline")
	console.log(timeline);
}

process.on('exit', finalize);
module.exports = key;
