'use strict';

if(!process.addAsyncListener)
    require('async-listener');

var tree = {};
var fs = require('fs');

var parent = 0;
var counter = 0;
var calls = [];
var len = 0;
var runningCall = 0;
/**
 * AsyncListener object
 */
var AsyncListener = {};

AsyncListener.create = function create() {
    // This always gets called in between before/after
    counter += 1;

    //if(counter === 2) console.trace();
    calls.push( {"parent":parent, "current":counter} );
    return counter;
};


AsyncListener.before = function before(context, tree) {
	calls[runningCall]["start"] = process.hrtime()[1];
    parent = tree;
};


AsyncListener.error = function error(tree, err) {
};

AsyncListener.after = function after(context, id){
	calls[runningCall]["end"] = process.hrtime()[1];
	runningCall = runningCall + 1;
}

var key = process.addAsyncListener(AsyncListener);

function printCalls(){
  console.log(calls);}

function get_tree( calls ) {
  var tree = { 0:{} }
  get_tree_helper( calls, tree[0],  0 );
  return tree;
}

function get_tree_helper(calls, tree, prevParent ) {
    for (var j = 0; j < calls.length; j++){
      call = calls[j];
      if (prevParent === call.parent ){
        tree[call.current] = {}
        get_tree_helper(calls, tree[call.current], call.current );
      }
    }
}


function tree_to_dot_code(){
  var str = "digraph {\n";

  for (var i = 0; i < len; i++){
  	console.log(calls[i]);
    var parent = calls[i].parent;
    var child = calls[i].current;
    str += parent + " -> " + child +"\n";
  }

  str += "}";

  return str;
}

function create_dot_file(){
  len = calls.length;
  var code = tree_to_dot_code() 
  fs.writeFileSync( 'dotgraph', code);
  console.log(code);
}

process.on('exit', create_dot_file);
module.exports = key;
