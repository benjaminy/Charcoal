'use strict';

if(!process.addAsyncListener)
    require('async-listener');

var tree = {};
var fs = require('fs');

var parentID = 0;
var callbackID = 0;
var asyncCallbacks = [];
var timeline = [];
var len = 0;
var runningCall = 0;
/**
 * AsyncListener object
 */
var AsyncListener = {};

AsyncListener.create = function create() {
    // This always gets called in between before/after
    callbackID += 1;

    //Signifies that a callback has been queued, but there is
    //no guarantee that this callback will run
    asyncCallbacks.push( {"initiator": parentID, "ID": callbackID} );
    return callbackID;
};


AsyncListener.before = function before(context, callbackID) {
    parentID = callbackID;

    //Because the order of creating callbacks is not the same as
    //the order in which these callbacks are executed, a timeline
    //can be kept
    timeline.push({"ID": callbackID, "start": process.hrtime()[1]});
};

AsyncListener.error = function error(tree, err) {
};

AsyncListener.after = function after(context, id){
	//Duration can be computed
	timeline[timeline.length - 1]["end"] = process.hrtime()[1];
}

var key = process.addAsyncListener(AsyncListener);

function printasyncCallbacks(){
  console.log(asyncCallbacks);
}

function get_tree( asyncCallbacks ) {
  var tree = { 0:{} }
  get_tree_helper(asyncCallbacks, tree[0],  0 );
  return tree;
}

function get_tree_helper(asyncCallbacks, tree, prevParent ) {
    for (var j = 0; j < asyncCallbacks.length; j++){
      var callback = asyncCallbacks[j];
      if (prevParent === call.initiator){
        tree[callback.ID] = {}
        get_tree_helper(asyncCallbacks, tree[callback.ID], callback.ID);
      }
    }
}


function tree_to_dot_code(){
  var str = "digraph {\n";

  for (var i = 0; i < len; i++){
  	var callback = asyncCallbacks[i];
  	console.log(callback);
    var parent = callback.initiator;
    var child = callback.ID;
    str += parent + " -> " + child +"\n";
  }

  str += "}";

  return str;
}

function create_dot_file(){
  //The length of asyncCallbacks GROWS even after process exits
  //Due to callbacks being queued during the exiting process..
  len = asyncCallbacks.length;
  console.log(timeline);
  var code = tree_to_dot_code() 
  fs.writeFileSync('dotgraph', code);
  console.log(code);
}

process.on('exit', create_dot_file);
module.exports = key;
