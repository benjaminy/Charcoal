// Generated by CoffeeScript 1.7.1
(function() {
  var Result;

  Result = (function() {
    function Result(profile) {
      this.ticks = profile.ticks;
      this.start = profile.start;
      this.end = profile.end;
    }

    Result.prototype.header = function() {
      var max, min, sum, tick, total, wait, _, _ref;
      sum = [0, 0];
      wait = [0, 0];
      min = [Infinity, Infinity];
      max = [0, 0];
      _ref = this.ticks;
      for (_ in _ref) {
        tick = _ref[_];
        if (tick.ignore) {
          continue;
        }
        if (tick.queue[0] < min[0] || (tick.queue[0] === min[0] && tick.queue[1] < min[1])) {
          min = tick.queue;
        }
        if (tick.end[0] > max[0] || (tick.end[0] === max[0] && tick.queue[1] > max[1])) {
          max = tick.end;
        }
        sum[0] += tick.end[0] - tick.start[0] - tick.overhead[0];
        sum[1] += tick.end[1] - tick.start[1] - tick.overhead[1];
        wait[0] += tick.start[0] - tick.queue[0];
        wait[1] += tick.start[1] - tick.queue[1];
      }
      total = [sum[0] + wait[0], sum[1] + wait[1]];
      return "total: " + (this.time(sum)) + "ms (in " + (this.diff(max, min)) + "ms real time, CPU load: " + ((this.time(sum) / this.diff(max, min)).toFixed(1)) + ", wait time: " + (this.time(wait)) + "ms)";
    };

    Result.prototype.print = function(parent, from, indent) {
      var i, tick, time, _i, _j, _ref, _ref1;
      if (parent == null) {
        parent = null;
      }
      if (from == null) {
        from = 0;
      }
      if (indent == null) {
        indent = "";
      }
      if (parent === null) {
        for (i = _i = from, _ref = this.ticks.length; from <= _ref ? _i < _ref : _i > _ref; i = from <= _ref ? ++_i : --_i) {
          if (!(this.ticks[i].queue && this.ticks[i].start && this.ticks[i].end)) {
            this.ticks[i].ignore = true;
          }
        }
        console.log(this.header());
      }
      for (i = _j = from, _ref1 = this.ticks.length; from <= _ref1 ? _j < _ref1 : _j > _ref1; i = from <= _ref1 ? ++_j : --_j) {
        tick = this.ticks[i];
        if (tick.parent !== parent) {
          continue;
        }
        if (tick.ignore) {
          continue;
        }
        if (tick.stack && !tick.mark) {
          tick.mark = this.getLineFromStack(tick.stack);
        }
        time = [tick.end[0] - tick.start[0] - tick.overhead[0], tick.end[1] - tick.start[1] - tick.overhead[1]];
        console.log("" + (this.diff(tick.start, this.start)) + ": " + (this.time(time)) + "ms " + indent + " " + (tick.mark || "[no mark]") + " (" + (this.time(tick.overhead)) + ")  ");
        this.print(tick, 0, indent + "  ");
      }
      if (parent === null) {
        return console.log("");
      }
    };

    Result.prototype.getLineFromStack = function(stack) {
      var l, lines, _i, _j, _k, _len, _len1, _len2, _ref;
      if (Error.prepareStackTrace) {
        stack = Error.prepareStackTrace(new Error("ohai"), stack);
      } else {
        stack = "new Error('ohai')\n" + stack.map(function(f) {
          return " at " + (f.toString()) + "\n";
        }).join("");
      }
      lines = stack.split("\n");
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        l = lines[_i];
        if (l.indexOf(process.cwd()) > -1 && l.indexOf('node_modules') < l.indexOf(process.cwd())) {
          return l.replace(/^\s*/, '');
        }
      }
      for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
        l = lines[_j];
        if (l.indexOf(process.cwd()) > -1) {
          return l.replace(/^\s*/, '');
        }
      }
      _ref = lines.slice(1);
      for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
        l = _ref[_k];
        if (l.indexOf('async-profile') === -1) {
          return l.replace(/^\s*/, '');
        }
      }
    };

    Result.prototype.diff = function(after, before) {
      return this.time([after[0] - before[0], after[1] - before[1]]);
    };

    Result.prototype.time = function(delta) {
      return ((1000 * delta[0]) + (delta[1] / 1000000)).toFixed(3);
    };

    Result.prototype.stop = function() {
      if (this.end) {
        return;
      }
      this.end || (this.end = process.hrtime());
      process.removeAsyncListener(this.listener);
      return this.opts.callback(this);
    };

    return Result;

  })();

  module.exports = Result;

}).call(this);
