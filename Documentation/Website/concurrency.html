<html>
<head>
<title>Concurrency</title>
<link rel="stylesheet" media="screen" type="text/css" href="charcoal.css"/>
</head>
<body style="background-color:darkgray">

<div class="side_links">
<a href="index.html">Charcoal</a><br/>
- <a href="short_version.html">Why Charcoal?</a><br/>
- <a href="some_examples.html">Examples</a><br/>
- <a href="concurrency.html">Concurrency</a><br/>
&mdash; <a href="concurrency.html#expressiveness">Expressiveness</a><br/>
&mdash; <a href="concurrency.html#performance">Performance</a><br/>
- <a href="big_four.html">vs. Threads, etc.</a><br/>
- <a href="implementation.html">Implementation</a><br/>
- <a href="faq.html">FAQ</a>
</div>

<div class="main_div">

<p>Concurrency is a big topic.  In the most zoomed-out view, concurrent
software has multiple "active" components &mdash; sometimes
called <em>processes</em> or <em>tasks</em> &mdash; that can make
progress simultaneously.  The simultaneity can be physical (different
tasks literally executing simultaneously on separate processors) or
simulated by interleaving the execution of multiple tasks on a single
processor.  <a href="concurrency.html">Here</a> is my take on some of
the most important concepts that fit under the concurreny umbrella.</p>

<h1>(1/3) Concurrency</h1>

<p>The reasons for making concurrent software can be lumped into two
main categories: performance and expressiveness.</p>

<ul>
<li><em>Performance</em> - There are multiple hardware resources of some
sort (processors, network interfaces, machines, ...) and we want our
software to use them simultaneously to improve some performance metric
(total run time, throughput, latency, whatever).
<li><em>Expressiveness</em> - Some program patterns are intrisically
concurrent (interactive programming <em>is</em> concurrenct
programming), and some programs can be more elegantly expressed by using
the right concurrency framework.
</ul>

<p>Of course a single application might use concurrency for many
reasons, but I think it's important to keep in mind that these are two
totally separate things.  The Charcoal project is principally focused on
the expressiveness part of the picture.</p>

<div class="highlight">
<table width="100%">
<caption align="bottom"><hr/>Figure 1: A map of the primary reasons for
using concurrency in software.  The check marks indicate the concepts
that the Charcoal project most directly addresses.</caption>
<tbody><tr><td>
<img src="./concurrency_concept_map.svg" width="100%"/>
</td></tr></tbody>
</table>
</div>

<a id="expressiveness"/>
<h1>(2/3) Expressiveness</h1>

The Charcoal project is primarily about the expressiveness side of the
concurrency concept map.  These concepts are about using concurrency in
software design not for performance benefits, but because it just makes
more sense that way.

<a id="reactive"/>
<h2>2.(1/3) Reactive/Interactive</h2>

<p>All software interacts with the real world in some way.  Some
applications have a relatively simple interactions pattern: read some
input, compute for a while, write some output.  Compilers are a good
example of software that is quite complex, but mostly adheres to this
simple interaction with the outside world.</p>

<p>Many applications, including most that people directly use on a
regular basis, have more complex interactions with the world.  Take a
spreadsheet as an example.  The application must be ready to react to
keyboard and mouse input from the user at any time.  Recalculating the
spreadsheet values may take a relatively long time for large documents,
and this process should be interruptable.  Also various background tasks
are probably happening periodically, like auto-saving backup copies and
checking formulas for possible errors.</p>

<p>Building reactive/interactive software is different.</p>

<a id="realtime"/>
<h3>2.1.(1/2) Real-time</h3>

<p>A special case of interactive software is those that have real-time
constraints (hard or soft).  This category includes multimedia software,
games, embedded systems controllers.</p>

<a id="disk"/>
<h3>2.1.(2/2) Disk/Network/UI</h3>

<p>One common and simple concurrency pattern in GUI applications is
starting long-running I/O operations, like disk or network reads,
while remaining responsive to user input.</p>

<p>This category is also connected to the concurrency part of the map,
because some software has high disk or network requirements and needs to
overlap many accesses in order to perform well.</p>

<a id="algorithmic"/>
<h2>2.(2/3) Algorithmic</h2>

<p>Some algorithms look "procedural/functional" from the outside, but
can still use concurrency to good effect internally.  A classic example
is programming language parsing.  Scanner; parser.</p>

<a id="isolation"/>
<h2>2.(3/3) Isolation</h2>

<p>Sometimes we want software components to be isolated from each other
in one way or another.  A couple of classic examples:</p>

<ul>
<li><em>Plugins</em>.  Many applications have plugins.  Often we want
the core application to be isolated from the plugins, in case the plugin
does something bad.
<li><em>Long-running Tasks</em>.  Often in GUI applications, many tasks
can be taken care of very quickly, but a few might run for a long time.
We need to isolate the long-running tasks in some way to ensure that the
application remains responsive.
</ul>

<a id="performance"/>
<h1>(3/3) Performance</h1>

Some applications 

<a id="processor"/>
<h2>3.(1/3) Processor Parallelism</h2>

For CPU-bound tasks.

<a id="multi"/>
<h3>3.1.(1/3) Multi-processors</h3>

Multi-cores and such.

<a id="gpu"/>
<h3>3.1.(2/3) Accelerators (GPU/FPGA)</h3>

Turbo boost.

<h3>3.1.(3/3) Distributed</h3>

<a href="#distributed">Here</a>

<a id="system"/>
<h2>3.(2/3) System Parallelism</h2>

For I/O-bound tasks.

<h3>3.2.(1/2) Disk/Network/UI</h3>

<a href="#disk">Here</a>

<a id="distributed"/>
<h3>3.2.(2/2) Distributed</h3>

Clusters.  Could be CPU-bound or IO/bound.

<h3>3.(3/3) Real-time</h3>

<a href="#realtime">Here</a>

<div><hr/>&copy; Copyright 2013 <a href="http://www.cs.cornell.edu/~biy3/">Benjamin Ylvisaker</a></div>

</div>
</body>
</html>
