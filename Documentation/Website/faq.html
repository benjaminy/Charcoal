<html>
<head>
<title>Charcoal FAQ</title>
<style media="screen" type="text/css">
pre { display:inline }
.highlight {
  background-color:white;
  padding:0.3em;
  margin:0.3em;
}
</style>
</head>
<body style="background-color:darkgray">

<div style="background-color:seashell;width:35em;margin-left:auto;margin-right:auto;padding:2em">

<h1>"Frequently" Asked Questions</h1>
<h3>a.k.a. questions that the authors feel like answering</h3>

<h4>Q01: Why design another programming language?</h4>

<p>It's true that there are too many programming languages in the world
already.  However, concurrency is one of the facets of programming
language design that really can't be done in any other way.  See, e.g., 
<a href="http://www.hpl.hp.com/techreports/2004/HPL-2004-209.html">Threads
Cannot be Implemented as a Library</a>.</p>

<h4>Q02: Why start with C?</h4>

<p>C is no longer the dominant appliation programming language in lots
of software domains.  However, it has two properties that make it
attractive for projects like this one:</p>

<ul>
<li>C is relatively simple, which means that extensions to its syntax
and semantics can be designed relatively easily.
<li>C is still the common language of system implementation.  If the
ideas that I am experimenting with in Charcoal gain any traction, I hope
that they will be integrated into a wide range of languages.  I expect
that choosing C as the basis will make it as easy as possible for other
developers to steal the ideas and implementation techniques.
</ul>

<h4>Q03: Isn't it dumb to make a concurrent language that can't be run
in parallel?</h4>

<p>As discussed elsewhere on this site, concurrency and parallelism
are <em>very</em> different topics.  Part of the inspiration behind this
project is that insisting on parallel execution is one of the
ingredients that makes multithreaded programming so error-prone.  There
is really no reason to want concurrency and parallelism to be mushed
together into a single language feature.  You need concurrency for
interaction and parallelism for speeding up CPU-bound algorithms.  There
is no reason to put the two in the same bucket.</p>

<h4>Q04: The world has existed happily with event handlers, threads,
etc. for decades now; did anything change to create a demand for a new
concurrency primitive?</h4>

<p>I'm not sure.  My sense is that with so much of the application
development action going on in the web, mobile and embedded parts of the
universe, there is genuinely more reactivity and interactivity compared
to a decade or two ago.  As circumstantial evidence, I point to all the
experimentation with funky event handling and cooperative threading
models going on in the "scripting" langauge space.  In particular, my
sense is that "regular joe" developers are coming face-to-face with
concurrency issues much more than in the past.  I would love to know if
anyone has actually studied these trends.</p>


<div><hr/>&copy; Copyright 2013 <a href="mailto:benjaminy@alumni.cmu.edu">Benjamin Ylvisaker</a></div>

</div>
</body>
</html>
