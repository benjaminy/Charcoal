[Miguel - June 27]
  - GOALS:
  	1. Fiz the graphs
  	2. Investigate gapping

[Miguel - June 26]
  - I performed some fixing and cleaning on the scripts
  - There is a particular concern with the data
  	1. The cumulative duration calls do not sum up to the total runtime of functions
  	2. In effect, the cumulative percentages of function durations to total function runtime does not converge to 1.

[Miguel - June 25]
  - Started to modulize the scripts, but more refinements have to be made with them, particular the data analysis
  - More cleaning, to accommodate Clara's involvement in the project
  - (!?) Added a simple guessing algorithm for finding the pids of processes of interest
    - It seems the case that the process of interest do on average have an extraordinary # of function calls
    - Does not work for ALL profiles, and sometimes may pick up rendering processes...

[Miguel - June 24]
  - Started to clean up the scripts / directions
  - The focus, by Ben's suggestion, will be to start looking for gaps between callbacks / events
  - Also, the idea of representative samples is still a concern, and a protocol for how to go about
    getting profiles may have to be addressed concretely soon
  
[Miguel - June 23]
  - I gathered some more sample performance profiles, but I am growing concerned with whether the profiles are representative of 
    JavaScript behavior of the sites from which they were derived
  - (!) Automation of profile analysis / graphing is looking a bit promising, as I think there is a structural pattern in what processes
    are of interest
  
[Miguel - June 22]
  - I implemented some scripts for graphing data
  - It's a little rough looking, and the script is beginning to become a bit messy, but I believe it has working value
  - I am suspecting that I will have to automate the process of looking at data eventually, and I wonder what sort 
    of statistical analysis can be performed en masse 
  
[Miguel - June 20]
 - (!) After consulting with Ben, it was determined that there may be a arguably straightforward way of extracting
   function duration data from Chrome's Performance Analyzer
 - For the sake of progress, I will assume his approach correct, but I will eventually "modulize" data extraction
 - Also, it was also decided that deriving causality in async activity may not be totally necessary, although
   I will keep it in mind
   
[Miguel - June 19]
 - Looked at Firefox developer tools a bit more intently to see if there are cleaner output files for
   determining function duration
 - Mozilla's performance analyzer does not yield intuitive, interpretable results
 - (?) There's an async parent attribute for Firefox's analyzer; simple overlapping asyc call tests suggest
       that it can't be used for causal relationships...
 
[Miguel - June 16] 
 - Output files of chrome's performance analyzer and the JavaScript Profiler is more cumbersome than I thought
 - On top of that, both tools rely on sampling to gain runtime information of functions
 - I am considering dabbling with the other browser dev-tools in hopes of cleaner output files
 
[Miguel - June 15] 
 - I followed Ben's suggestion to look at the async listener, and skimmed the code. 
 - Seems quite promising, if I understood the AsyncListener implementation well enough (separate from the tree)
 - Will follow up on the AsyncListner implementation, as well as the Node.js native api for async handling and
   process handling... still having issues with data gathering.
    
[Miguel - June 14]
 - The output file of the current profilers / tracers do not format function time in an obvious way 
   (there's no attribute like "duration")
 - I have some leads but nothing solid on how to derive this data
 	
[Miguel - June 13]
 - I decided to focus on the output of the performance analyzer. It is arguably more 
   descriptive in profiling an application during runtime.
 - However, causal relationships are not mapped in the profiler, outside of timeouts
 - There is reason to suppose that Chrome does, at the very least, can keep track of asynchronous activity because
   it does so through a stack trace.
 
[Miguel - June 12]
 - Several findings with the inspector
 	- A JavaScript profiler: Handles specifically functional calls during the runtime of an application in Chrome
 	- Performance analyzer receives runtime information with a trace of all named function calls, as well as events
 - Creating scripts that work with the JS Profiler, the Performance Analyzer, and the Event Trace seems to be needed in order
   to greater understand causality relationships in a profile.
 - In this, it is questionable whether analysis should occur in the scripts or in external applications.
 - (!) It may be possible to use the performance analyzer to derive event/callback relationships, but the
    output file is dense...
 
[Miguel - June 9]
 - Focus has been given to doing some basic data analysis
 - My datautil module will be a dump file for any tools needed to process profiles
 - So far, trying to manipulate the output data for Event Profiler tool in a GENERIC way is a bit harder than expected,
   and I do not want to ad-hoc the process in case I find other tools to supplement the output data. 
 - Looking for other tools are still on-going.
   
[Miguel - June  7]
 - I learned a working amount of Python to make scripts that can read from JSON files and manipulate them
 - I am developing a set of utility functions to manipulate the data from the Chrome Event Profiler
 - I will make more effort into understanding several key questions that I have:
 	1. How would the theoretical concurrency bug that can result from series of call backs look like in the profiler?
 	2. What other processes that the Event Profiler traces that could contribute to concurrency concerns 
 	   beyond the v8 category?
 - To begin to answer these questions, I will look into other tools beyond just the Chrome developer 
   tools to see if there is some way to provide more information about events.
 
[Miguel - June 2]

 - Looked into the inspector tool and made several observations. Of them, the several are important:
	1. It is possible to stop the execution of a program and still have the Chrome Event Profiler run
	2. The profiler will show when events/functions calls has not finished when a trace ends
 - Also, another thing passively observed: the Profiler will trace events across all tabs, not just 'opened' ones.

[Miguel - June 1]
 - Progress was made in identifying callbacks using simple test JavaScript programs.
 - Using event categories v8 and v8.execute (credit to Ben), I was able to see how the event tracer profiles callbacks. Namely, in
   the case of setTimeout(), it appears as ScheduleAction::execute; profiles of callbacks outside of functions such as setTimeout()
   seem to appear as sequences of events, instead of stacks of functions, but I find this odd and will continue to look at this.
 - Also, I will look into how to use the event tracer with other developer tools, mainly the inspector, to achieve greater control
   over the execution of a program.

[Miguel - May 31]
 - Progress was made in understanding a trace profile
 - There are obstacles in extracting wanted data
    1. There are a lot of events being traced irrelevant to our purposes
    2. Lack of definition in function calls
 - Effort will be made in identifying useful data by tracing simple JavaScript / HTML programs. This will help me understand what
   to look for in a event trace of a complex application
   
[BY - May 24]
Background for the summer project with Clara & Miguel:
- Very broad, old-ish background on the challenges of concurrency:
  - https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf
  - https://people.eecs.berkeley.edu/~brewer/papers/threads-hotos-2003.pdf
- More recent references TBD
- What I am expecting us to do:
  - Instrument JS ecosystems (browsers, node, electron, others?)
  - Collect traces of event callbacks from real applications
  - Analyze these traces for potentially problematic patterns
- What I am hoping/expecting to find:
  - Many applications are composed of tons of extremely short callbacks.
    Sometimes there are chains of callbacks that typically execute in short succession.
    If some other action happened in the middle of such a chain, it could cause a concurrency bug.

First steps:
- Gain familiarity with JavaScript event logging/tracing tools. For example (these are just starting points):
  - https://developers.google.com/web/tools/chrome-devtools/console/events
  - https://nodejs.org/api/tracing.html
