[Miguel - June 12]
 - Several findings with the inspector
 	- A JavaScript profiler: Handles specifically functional calls during the runtime of an application in Chrome
 	- Performance analyzer receives runtime information with a trace of all named function calls, as well as events
 - Creating scripts that work with the JS Profiler, the Performance Analyzer, and the Event Trace seems to be needed in order
   to greater understand causality relationships in a profile.
 - In this, it is questionable whether analysis should occur in the scripts or in external applications.
 - (!) It may be possible to use the performance analyzer to derive event/callback relationships, but the
    output file is dense...
 
[Miguel - June 9]
 - Focus has been given to doing some basic data analysis
 - My datautil module will be a dump file for any tools needed to process profiles
 - So far, trying to manipulate the output data for Event Profiler tool in a GENERIC way is a bit harder than expected,
   and I do not want to ad-hoc the process in case I find other tools to supplement the output data. 
 - Looking for other tools are still on-going.
   
[Miguel - June  7]
 - I learned a working amount of Python to make scripts that can read from JSON files and manipulate them
 - I am developing a set of utility functions to manipulate the data from the Chrome Event Profiler
 - I will make more effort into understanding several key questions that I have:
 	1. How would the theoretical concurrency bug that can result from series of call backs look like in the profiler?
 	2. What other processes that the Event Profiler traces that could contribute to concurrency concerns 
 	   beyond the v8 category?
 - To begin to answer these questions, I will look into other tools beyond just the Chrome developer 
   tools to see if there is some way to provide more information about events.
 
[Miguel - June 2]

 - Looked into the inspector tool and made several observations. Of them, the several are important:
	1. It is possible to stop the execution of a program and still have the Chrome Event Profiler run
	2. The profiler will show when events/functions calls has not finished when a trace ends
 - Also, another thing passively observed: the Profiler will trace events across all tabs, not just 'opened' ones.

[Miguel - June 1]
 - Progress was made in identifying callbacks using simple test JavaScript programs.
 - Using event categories v8 and v8.execute (credit to Ben), I was able to see how the event tracer profiles callbacks. Namely, in
   the case of setTimeout(), it appears as ScheduleAction::execute; profiles of callbacks outside of functions such as setTimeout()
   seem to appear as sequences of events, instead of stacks of functions, but I find this odd and will continue to look at this.
 - Also, I will look into how to use the event tracer with other developer tools, mainly the inspector, to achieve greater control
   over the execution of a program.

[Miguel - May 31]
 - Progress was made in understanding a trace profile
 - There are obstacles in extracting wanted data
    1. There are a lot of events being traced irrelevant to our purposes
    2. Lack of definition in function calls
 - Effort will be made in identifying useful data by tracing simple JavaScript / HTML programs. This will help me understand what
   to look for in a event trace of a complex application
   
[BY - May 24]
Background for the summer project with Clara & Miguel:
- Very broad, old-ish background on the challenges of concurrency:
  - https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf
  - https://people.eecs.berkeley.edu/~brewer/papers/threads-hotos-2003.pdf
- More recent references TBD
- What I am expecting us to do:
  - Instrument JS ecosystems (browsers, node, electron, others?)
  - Collect traces of event callbacks from real applications
  - Analyze these traces for potentially problematic patterns
- What I am hoping/expecting to find:
  - Many applications are composed of tons of extremely short callbacks.
    Sometimes there are chains of callbacks that typically execute in short succession.
    If some other action happened in the middle of such a chain, it could cause a concurrency bug.

First steps:
- Gain familiarity with JavaScript event logging/tracing tools. For example (these are just starting points):
  - https://developers.google.com/web/tools/chrome-devtools/console/events
  - https://nodejs.org/api/tracing.html
